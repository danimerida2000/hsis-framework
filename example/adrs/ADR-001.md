# ADR-001: Use Redis for Cart Caching

## Status
Accepted

## Date
2024-01-16

## Deciders
- Architect Agent (Codex CLI)

---

## Context

### Problem Statement
Cart operations need to meet NFR-001 (≤500ms P95 latency). Direct database queries for every cart operation may not meet this performance requirement, especially under load.

### Driving Forces
- **NFR-001**: Cart operations must complete in ≤500ms at P95
- **NFR-005**: System must support 10,000 concurrent cart operations
- **Scalability**: Cart service will scale horizontally, requiring shared cache

### Requirements Context
| Requirement ID | Requirement | Relevance |
|----------------|-------------|-----------|
| NFR-001 | P95 latency ≤500ms | Direct requirement for fast reads |
| NFR-005 | 10K concurrent operations | Need distributed cache for scale |

---

## Decision

### Chosen Option
**Redis as distributed cache layer**

Cart data will be cached in Redis with a cache-aside pattern:
- Read: Check cache first, fallback to DB, populate cache
- Write: Update DB first, then invalidate cache
- TTL: 1 hour for cart data
- Key format: `cart:{userId}`

### Implementation Guidelines
1. Use Redis Cluster for high availability
2. Implement cache invalidation on all write operations
3. Use optimistic locking to prevent stale cache issues
4. Implement circuit breaker for Redis failures with DB fallback

---

## Consequences

### Positive
- **Fast reads**: Cache hits return in <10ms vs 50-100ms DB queries
- **Reduced DB load**: Most reads served from cache
- **Horizontal scalability**: Distributed cache supports multiple service instances
- **Session affinity not required**: Any service instance can serve any user

### Negative
- **Operational complexity**: Additional Redis cluster to manage
- **Cache consistency**: Must carefully handle invalidation
- **Memory cost**: Additional infrastructure cost for Redis

### Neutral
- Redis is already used for session storage, so no new technology

---

## Alternatives Considered

### Alternative 1: In-Memory Cache (Node.js)
**Description**: Use node-cache or similar for process-local caching

**Pros**:
- Simple to implement
- No additional infrastructure

**Cons**:
- Requires session affinity (sticky sessions)
- Cache duplicated across instances
- Cache lost on service restart

**Rejection Reason**: Doesn't support horizontal scaling or multi-instance deployments

---

### Alternative 2: PostgreSQL Materialized Views
**Description**: Pre-compute cart totals in materialized views

**Pros**:
- Single data source
- Transactionally consistent

**Cons**:
- Refresh lag for real-time data
- Still requires DB roundtrip
- Complex refresh strategy

**Rejection Reason**: Doesn't improve read latency enough for real-time operations

---

### Alternative 3: No Caching
**Description**: Optimize DB queries with proper indexing

**Pros**:
- Simplest implementation
- Always consistent

**Cons**:
- May not meet performance targets under load
- Higher DB connection usage

**Rejection Reason**: Risk of not meeting NFR-001 under peak load

---

## Validation

### How We'll Know This Works
- Load test shows P95 latency ≤500ms at 10K concurrent operations
- Cache hit rate >90% for cart read operations
- No consistency issues in E2E tests

### Tests
| Test Type | Test Name | Purpose |
|-----------|-----------|---------|
| Unit | cart-cache.test.ts | Validate cache operations |
| Integration | cache-consistency.test.ts | Validate invalidation |
| Load | cart-operations.test.ts | Validate performance targets |

---

## Links

### Requirements
- NFR-001: Cart operation latency
- NFR-005: Concurrent operation support

### Related ADRs
- None

### Implementation
- `src/cache/cart.cache.ts`
- `tests/unit/cache/cart-cache.test.ts`
